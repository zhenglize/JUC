                    AQS内部原理解析
◆AQS最核心的就是3三大部分:
        ◆state
        ◆控制线程抢锁和配合的FIFO队列
        ◆期望协作工具类去实现的获取/释放等重要方法
state状态
◆这里的state的具体含义,会根据具体实现类的不同而不同，比如在Semaphore里,它表示“剩余的许可证的数量”,
  而在CountDownLatch里，它表示“还需要倒数的数量’
◆state是volatile修饰的,会被并发地修改,所以所有修改state的方法都需要保证线程安全,比如getState、setState以及
  compareAndSetState操作来读取和更新这个状态。这些方法都依赖于j.u.c.atomic包的支持
  在ReentrantLock中。state用来表示”锁”的占有情况,包括可重入计数。当state的值为0的时候,
  标识改Lock不被任何线程所占有

控制线程抢锁和配合的FIFO队列
◆这个队列用来存放”等待的线程”, AQS就是"排队管理器'，当多个线程争用同一把锁时,必须有排队机制将那些没能拿到
  锁的线程串在一起。当锁释放时,锁管理器就会挑选一个合适的线程来占有这个刚刚释放的锁。
◆AQS会维护一个等待的线程队列 ,把线程都放到这个队列里。
◆这是一个双向形式的队列

获取方法
◆获取操作会依赖state变量,经常会阻塞(比如获取不到锁的时候)
◆在Semaphore中,获取就是acquire方法,作用是获取一个许可证
◆而在CountDownLatch里面,获取就是await方法,作用是"等待，直到倒数结束”






