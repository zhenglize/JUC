                    乐观锁与悲观锁
悲观锁:
◆如果我不锁住这个资源,别人就会来争抢,就会造成数据结果错误,所以每次悲观锁为了确保结果的正确性,会在每次获取
  并修改数据时,把数据锁住,让别人无法访问该数据,这样就可以确保数据内容万无一失.
◆Java中悲观锁的实现就是synchronized和Lock相关类

乐观锁：
◆认为自己在处理操作的时候不会有其他线程来干扰,所以并不会锁住被操作对象.
◆在更新的时候,去对比在我修改的期间数据有没有被其他人改变过。如果没被改变过,就说明真的是只有我自己在操作,
  那我就正常去，修改数据。
◆如果数据和我一开始拿 到的不一样了, 说明其他人在这段时间内改过数据,那我就不能继续刚才的更新数据过程了,
  我会选择放弃、报错、重试等策略。
◆乐观锁的实现一般都是利用CAS算法来实现的
◆Git : Git就是乐观锁的典型例子,当我们往远端仓库push的时候, git会检查远端仓库的版本是不是领先于我们现在
  的版本,如果远程仓库的版本号和本地的不一样,就表示有其他人修改了远端代码了, 我们的这次提交就失败;如果远端
  和本地版本号一致,我们就可以顺利提交版本到远端仓库
◆常见的乐观锁有并发容器和典型的原子类

开销对比:
◆悲观锁的原始开销要高于乐观锁,但是特点是一劳永逸,临界区持锁时间就算越来越差,也不会对互斥锁的开销造成影响
◆相反，虽然乐观锁一开始的开销比悲观锁小,但是如果自旋时间很长或者不停重试,那么消耗的资源也会越来越多

适用场景:
◆悲观锁:适合并发写入多的情况,适用于临界区持锁时间比较长的情况,悲观锁可以避免大量的无用自旋等消耗,典型情况:
         1 临界区有IO操作
         2 临界区代码复杂或者循环量大
         3 临界区竞争非常激烈，
◆乐观锁:适合并发写入少,大部分是读取的场景,不加锁的能让读取性能大幅提高。

为什么需要乐观锁?
悲观锁的劣势
◆阻塞和唤醒带来的性能劣势
◆永久阻塞:如果持有锁的线程被永久阻塞,比如遇到了无限循环、死锁等活跃性问题，那么等待该线程释放锁的线程将
  永远无法执行
◆优先级反转:低优先级的锁会一直占有锁的资源。使得高优先级的锁得不到锁。从而导致了优先级反转的情况。
