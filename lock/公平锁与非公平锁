                       公平锁与非公平锁
◆公平锁，就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程
         是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己

◆非公平指的是,不完全按照请求的顺序,在一定情况下,可以插队。
  注意:非公平也同样不提倡"插队”行为,这里的非公平,指的是"在合适的时机”插队,而不是盲目插队。

◆这样设计的目的是为了提高效率,避免唤醒线程带来的空档期

并发包中ReentrantLock的创建可以指定构造函数的boolean类型来得到公平锁或非公平锁，默认是非公平锁
非公平锁的优点在于吞吐量比公平锁大。
对于Synchronized而言， 也是一种非公平锁

公平锁与非公平锁的特例
◆针对tryLock方法,它不遵守设定的公平的规则
◆例如,当有线程执行tryLock()的时候, 一旦有线程释放了锁,那么这个正在tryLock的线程就能获取到锁,
  即使在它之前已经有其他现在在等待队列里了

公平锁的优缺点:
优点:各线程公平平等,每个线程在等待一段时间后 ,总有执行的机会
缺点:更慢,吞吐量更小

非公平锁的优缺点
有点:更快,吞吐量更大
缺点:有可能产生线程饥饿,也就是某些线程在长时间内,始终得不到执行