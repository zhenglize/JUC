Synchronized关键字的作用
能够保证同一时刻最多只有一个线程执行该段代码，以达到并发安全的效果

为什么两个线程执行i++比预期的结果要少？
因为i++本质上是三个操作
从内存中读取i
将i的值增加
将i写回到内存中
这个过程并不能保证原子性，所以i++要比预期的结果要少

Synchronized的两个用法
1.对象锁
包括方法锁（默认对象为this当前实例对象）和同步代码块锁自己制定锁对象
2.类锁
指synchronized修饰的静态方法或指定锁为class对象

Synchronized性质
锁的粒度是线程
可重入:同一线程外层函数获取到该锁的时候，内层函数可以直接获取到该锁
好处:避免死锁，提升了封装性
不可中断:一旦别人获得了锁，如果我要获得锁的时候只能去等待别的线程去释放锁

synchronized的实现原理
当进入Synchronized代码块的时候，通过MonditorEnter来获取锁的资源，此时锁的计数器加一，其他线程看到
锁的计数器不为0的时候，进入阻塞状态，当发生MonditorExit指令的时候释放锁的资源，由于synchronized
是可重入锁，当退出锁的代码块和出现异常的时候都会触发MonditorExit这个指令。来使锁的计数器往下减。

可重入的原理
JVM负责跟踪对象的加锁次数
线程第一次给对象加锁的时候计数器变为1，每当有相同的线程作用在此对象获得锁的时候计数器增加
当任务离开的时候，计数器递减，当计数为0的时候，释放锁

synchronized可见性的保证
JMM内存模型

缺陷
效率低:锁的释放情况少，尝试获得锁时不能设置超时，不能中断一个尝试去获得锁的线程
不够灵活（没有读写锁灵活）:加锁释放锁的时机单一
无法知道是否成功的获取到了这个锁

常见的面试问题
synchronized需要注意的问题
锁对象不能为空，锁的作用域不能过大，要避免死锁